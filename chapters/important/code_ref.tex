\section{Code Commands}\label{code-commands}

This is the list of commands that I have careful stored

\subsection{Other Commands}\label{other-commands}

\begin{verbatim}
sudo -i

root@dockerhost:~# nc -l 443
\end{verbatim}

\begin{verbatim}
echo | <command>
echo | surge
\end{verbatim}

\begin{quote}
Deploys the app to surge without any prompts
\end{quote}

\hypertarget{docker-commands}{%
\subsection{Docker Commands}\label{docker-commands}}

\hypertarget{bash}{%
\subsection{Bash}\label{bash}}

\begin{quote}
printenv command -- Print all or part of environment
\end{quote}

\begin{verbatim}
sed -e '/pattern="MVG"/s/(^.*$)/<!--\1-->/' policy.xml > policy_test.xml
<policy domain="coder" rights="none" pattern="MVG" />
<!--  <policy domain="coder" rights="none" pattern="MVG" />-->
\end{verbatim}

\begin{verbatim}
sed -i -e 's/rights="none" pattern="PDF"/rights="read|write" pattern="PDF"/g' policy_test.xml
\end{verbatim}

\subsection{Windows}\label{windows}

\begin{verbatim}
taskkill /im node.exe /F
refreshenv
\end{verbatim}

where ping Taskkill is a built-in windows command that, well, kills a
task! the /im flag stands for "imagename", and it lets you pass in the
image name of the process to be terminated which is node.exe in this
case. The /F flag is optional and forces termination of the process.


\subsection{Gitlab}\label{gitlab}

\url{https://gitlab.com/profile/pipeline_quota}

How many minutes I have used, lol heroku-ping doesn't register, maybe it
occurs too quickly, or pages doesn't count as CI.

\subsection{BitBucket}\label{bitbucket}

main account 012345 pass: bchain050

\subsubsection{Git}\label{git}

Undo changes made in a specific folder in Git

\begin{verbatim}
git checkout <folder 
\end{verbatim}

\subsection{MegaTools}\label{megatools}

All Books I find "useful" will get dumped to my mega account using the
shell tools.

All remote directories start with /Root

\begin{verbatim}
megals -u <USERNAME> -p <PASSWORD>
megacopy -u <USERNAME> -p <PASSWORD> -l <LOCAL_DIR> -r <REMOTE_DIR>
\end{verbatim}

\subsection{GCP Useful Commands}\label{gcp-useful-commands}

\begin{verbatim}
# Creating a new python environment 
# See https://conda.io/docs/user-guide/tasks/manage-python.html#installing-a-different-version-of-python
conda create -n py36 python=3.6 anaconda
source activate py36
#Installing a new package 
conda install -c omnia hmmlearn
# Finding the list of environments for conda 
conda list 
# To install new kernel for juypter notebook 
python -m ipykernel install --user --name myenv --display-name "Python (myenv)"
\end{verbatim}

\subsection{Gitlab Runner Config}\label{gitlab-runner-config}

Remember to

\begin{verbatim}
sudo chmod +x /etc/gitlab-runner/config.toml
\end{verbatim}


\subsection{Node}\label{node}

\begin{verbatim}
npm cache clean -f
\end{verbatim}


\subsection{Ubuntu \& Linux}\label{ubuntu-linux}

Get csv nth csv column, for first column and quotes.csv

..code-block:: awk -F ""\emph{,"}" '\{print \$1 ","\}' quotes.csv

STorage at
C:UsersstudeAppDataLocalPackagesCanonicalGroupLimited.Ubuntu18.04onWindows\_79rhkp1fndgscLocalStaterootfs

or
C:UsersstudeAppDataLocalPackages\textless DISTRO\textgreater LocalStaterootfs

Yes it is possible, just redirect the output to a file:

..code-block:: shell SomeCommand \textgreater{} SomeFile.txt

Or if you want to append data:

..code-block:: shell SomeCommand \textgreater\textgreater{} SomeFile.txt

..code-block:: shell taskkill /im node.exe

\begin{verbatim}
\end{verbatim}

\begin{verbatim}
\end{verbatim}


\section{Commands}\label{commands}

\begin{Shaded}
\NormalTok{vendor/bin/phpunit --coverage-html docs --testsuite FeatureV4}
\end{Shaded}

\begin{verbatim}
sudo -i

root@dockerhost:~# nc -l 443
\end{verbatim}


\section{Scripts and Tools}\label{scripts-and-tools}


\subsection{Git Tips}\label{git-tips}

See
\href{https://serverfault.com/questions/50775/how-do-i-change-my-private-key-passphrase}{Private key passphrase}


\subsubsection{Postgres}\label{postgres}

To start running postgres server

\begin{verbatim}
pg_ctl.exe restart -D "C:\Program Files\PostgreSQL\9.6\data"
\end{verbatim}

to quit psql Type q and then press ENTER

Ctrl + D is what I usually use to exit psql console.


\paragraph{Making DB}\label{making-db}

\begin{verbatim}
postgres=# CREATE DATABASE test;
CREATE DATABASE
postgres=# \c test 
\dt 
\q
\end{verbatim}


\begin{lstlisting}[caption={Python Script to download from google drive}]
import requests
import os

def download_file_from_google_drive(id, destination):
  URL = "https://docs.google.com/uc?export=download"

  session = requests.Session()

  response = session.get(URL, params = { 'id' : id }, stream = True)
  token = get_confirm_token(response)

  if token:
      params = { 'id' : id, 'confirm' : token }
      response = session.get(URL, params = params, stream = True)

  save_response_content(response, destination)    

def get_confirm_token(response):
    for key, value in response.cookies.items():
        if key.startswith('download_warning'):
            return value

    return None

def save_response_content(response, destination):
    CHUNK_SIZE = 32768

    with open(destination, "wb") as f:
        for chunk in response.iter_content(CHUNK_SIZE):
            if chunk: # filter out keep-alive new chunks
                f.write(chunk)

if __name__ == "__main__":
    # https://drive.google.com/open?id=0B5ZnjTeo6iUYODZPVVQtVjhDa1E
    # https://drive.google.com/open?id=0B5ZnjTeo6iUYSy1DcFZwRlphTEE
    # https://drive.google.com/open?id=0B5ZnjTeo6iUYM2Y3Zk1oYWxGYzQ
    # iterate across id list 
    id_list = ['0B5ZnjTeo6iUYODZPVVQtVjhDa1E',
    '0B5ZnjTeo6iUYSy1DcFZwRlphTEE', '0B5ZnjTeo6iUYM2Y3Zk1oYWxGYzQ']
    for index, file_id in enumerate(id_list):
        destination = 'BLJM61331.part{}.rar'.format(index)
        # check if file exists
        exists = os.path.isfile(destination)
        if exists:
            print('skipping {}'.format(destination))
        else:
           download_file_from_google_drive(file_id, destination)
        # file_id = 'TAKE ID FROM SHAREABLE LINK'
        # destination = 'DESTINATION FILE ON YOUR DISK'
\end{lstlisting}

% Original idea was from stack overflow
\begin{lstlisting}[caption={Python Script to remove watermark}]
import cv2
import numpy as np

img = cv2.imread("MT-2005-1.jpg")

alpha = 2.0
beta = -160

new = alpha * img + beta
new = np.clip(new, 0, 255).astype(np.uint8)

cv2.imwrite("MT-2005-1-no-w.png", new)
\end{lstlisting}


\begin{lstlisting}[caption={Bash Script for kubernates}]
kubetcl get services
kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080
kubectl describe services/kubernetes-bootcamp

export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')
curl $(minikube ip):$NODE_PORT

kubectl describe deployment
kubectrl get pods -l run= kubernetes-bootcamp 
kubectrl get services -l run=kebernetes-bootcamp
kubectl label pod $POD_NAME app=v1
kubectl describe pods $POD_NAME
kubectl delete service -l run=kebernetes-bootcamp
kubectl get services 
curl $(minikube ip):$NODE_PORT 
kubectl exec -ti $POD_NAME curl localhost:8080
\end{lstlisting}


\begin{lstlisting}[caption={Bash Script uncomment line in sed for osx}]
#!/bin/bash
sed -i '' "8,8 s#//##" $BITRISE_SOURCE_DIR/src/helpers/constants/config.js
\end{lstlisting}

Upgrade the php upload limit on linux ami for codeformation launched wordpress instance.

\begin{verbatim}
sudo vim php.ini in /etc
run sudo service httpd graceful
\end{verbatim}

% Add basic linux commands and or windows commands
% where, etc ... 

% Updating lstinputlisting
\lstinputlisting[caption={Powershell script to install key software}]{chapters/important/scripts/install.ps1}


\lstinputlisting[caption={Bash Script to check python version}]{chapters/important/scripts/install.ps1}


To get all the latest commits since the last tags on windows
\begin{verbatim}
for /f "delims=" %a in ('git describe --tags --abbrev^=0') do @set latesttag=%a
git log %latesttag%..HEAD --oneline
\end{verbatim}

on linux

\begin{verbatim}
git log $(git describe --tags --abbrev=0)..HEAD --oneline
\end{verbatim}

To deploy to nuget, make sure I push up tags first and then create releases from the tags.

Creating a new tag with a release does not trigger github actions.

\begin{lstlisting}[caption={Bash Script to get largest files}]
#!/bin/bash
du -sk * | sort -rn | head
\end{lstlisting}
