\begin{mdframed}[style=theorem, frametitle={Algorithm Features}]
	A good algorithm must have three features: correctness, maintainability, and
effciency.
\end{mdframed}

\begin{mdframed}[style=important, frametitle={Data Structures}]
The term data structure refers to the organization of data in a
computer's memory, in order to retrieve it quickly for processing.
It is a scheme for data organization to decouple the functional
definition of a data structure from its implementation. A data
structure is chosen based on the problem type and the
operations performed on the data.
\end{mdframed}

There are five basic rules for calculating an algorithm’s Big O notation.

\begin{enumerate}
\item If an algorithm performs a certain sequence of steps f(N) times for a mathematical function f, then it takes O(f(N)) steps.
\item  If an algorithm performs an operation that takes O(f(N)) steps and then
performs a second operation that takes O(g(N)) steps for functions f and
g, then the algorithm’s total performance is O(f(N) g(N)).
\item  If an algorithm takes $O(f(N)+g(N))$ time and the function f(N) is greater
than g(N) for large N, then the algorithm’s performance can be simplified
to $O(f(N))$.
\item  If an algorithm performs an operation that takes $O(f(N))$ steps, and for
every step in that operation it performs another $O(g(N))$ steps, then the
algorithm’s total performance is $O(f(N)\times g(N)$.
\item  Ignore constant multiples. If C is a constant, $O(C \times f(N))$ is the same as
$O(f(N))$, and $O(C \times f(N))$ is the same as O(f(N)).

Adapter, bridge, composite,
decorator, facade, flyweight, private class data, and proxy are the
Gang of Four (GoF) structural design patterns. 

The adapter pattern comprises the target, adaptee, adapter, and
client:
\begin{itemize}
\item Target is the interface that the client calls and invokes
methods on the adapter and adaptee.
\item The client wants the incompatible interface implemented
by the adapter.
\item The adapter translates the incompatible interface of the
adaptee into an interface that the client wants.
\end{itemize}

\lstinputlisting[caption={Golang Adaptor Example}]{chapters/important/algorithms/adaptor.go}

\textbf{Bridge}
Bridge decouples the implementation from the abstraction. The
abstract base class can be subclassed to provide different
implementations and allow implementation details to be
modified easily. The interface, which is a bridge, helps in making
the functionality of concrete classes independent from the
interface implementer classes. The bridge patterns allow the
implementation details to change at runtime.

\lstinputlisting[caption={Golang Adaptor Example}]{chapters/important/algorithms/bridge.go}


\begin{mdframed}[style=important, frametitle={Composite}]
A composite is a group of similar objects in a single object.
Objects are stored in a tree form to persist the whole hierarchy.
The composite pattern is used to change a hierarchical collection
of objects. 
\end{mdframed}

The composite pattern comprises the component interface, component
class, composite, and client:
\begin{itemize}
	\item The component interface defines the default behavior of all
	objects and behaviors for accessing the components of
	the composite.
	\item  The composite and component classes implement the component
	interface.
	\item The client interacts with the component interface to
	invoke methods in the composite.
\end{itemize}

\begin{mdframed}[style=important, frametitle={Decorator}]
In a scenario where class responsibilities are removed or added,
the decorator pattern is applied. The decorator pattern helps
with subclassing when modifying functionality, instead of static
inheritance. An object can have multiple decorators and runtime decorators. The single responsibility principle can be
achieved using a decorator.
\end{mdframed}
