
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Some Author" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>Webpage Title — Glossary</title>
<link rel="stylesheet" href="prism.css" type="text/css">
<script src="prism.js" type="text/javascript"> </script>
<link rel="stylesheet" type="text/css" href="lwarp_sagebrush.css" />



<script>
// Lwarp MathJax emulation code
// Based on code by Davide P. Cervone.
// Original code: https://github.com/mathjax/MathJax/issues/2313
// Modified by Brian Dunn to adjust equation numbering, add subequations,
// and add starred macros.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred macros: https://github.com/mathjax/MathJax/issues/2428
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
         load: ['[tex]/tagFormat']
     },
     startup: {
         ready() {
              //
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              //
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //
              //       These are the names of the command maps:
              //
              const SETEQNUMBERMAP = 'seteqnumberCoreMap' ;


              //
              //       These functions implement the macros:
              //
              const seteqnumberFunction = (parser, name) => {
                   //       Get the macro parameters
                   const star = parser.GetStar();                                 // true if there is a *
                   const optBrackets = parser.GetBrackets(name);                  // contents of optional brackets
                   const newsubequations = parser.GetArgument(name);                 // the subequations argument
                   const neweqsection = parser.GetArgument(name);                 // the eq section argument
                   const neweqnumber = parser.GetArgument(name);                  // the eq number argument
                   MathJax.config.subequations=newsubequations ;                  // a string with boolean meaning
                   MathJax.config.section=neweqsection ;                          // a string with numeric meaning
                   parser.tags.counter = parser.tags.allCounter = neweqnumber ;
              };


              //
              //       This is the configuration for the seteqnumberFunctionConfig TeX extension.
              //
              const seteqnumberFunctionConfig = Configuration.create('seteqnumberCore', {
                   //
                   // Initialize the extension by creating the command map,
                   // then append the command map to the given configuration as a macro handler.
                   //
                   init(config) {
                        const map = new CommandMap(SETEQNUMBERMAP,{},{});
                        config.append(
                            Configuration.create(
                                      'seteqnumberDefs',
                                      {handler: {macro: [SETEQNUMBERMAP]}}
                            )
                        );
                   },


                   //
                   //       Add options (from the
                   //       seteqnumberCore configuration object in the document's
                   //       option list, if any).
                   //
                   config(config, jax) {
                        const map = jax.parseOptions.handlers.retrieve(SETEQNUMBERMAP);
                        const options = jax.parseOptions.options.seteqnumberCore;
                        for (const cs of Object.keys(options)) {
                            map.add(cs, new Macro(cs, seteqnumberFunction, options[cs]));
                        }
                   },


                   options: {
                        seteqnumberCore: expandable({})
                   }
              }
              );


              const IFSTARMAP = 'ifstarMap';


              //
              //       This function implements an ifstar macro.
              //
              const IfstarFunction = (parser, name, resultstar, resultnostar) => {
                   //
                   //       Get the macro parameters
                   //
                   const star = parser.GetStar();                       // true if there is a *
                   //
                   //       Construct the replacement string for the macro
                   //
                   const macro = [(star ? resultstar : resultnostar)].join('');
                   //
                   //       Insert the replacement string into the TeX string, and check
                   //       that there haven't been too many maxro substitutions (prevents
                   //       infinite loops).
                   //
                   parser.string = ParseUtil.addArgs(parser, macro, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                                                   'MathJax maximum macro substitution count exceeded; ' +
                                                   'is there a recursive macro call?');
                   }
              };


              //
              //       This is the configuration for the IfstarConfiguration TeX extension.
              //
              const IfstarConfiguration = Configuration.create('Ifstar', {
                   //
                   //       Initialize the extension by creating the command map for the
                   //       macros defined by \DeclareIfstar, and add the
                   //       \DeclareIfstar macro itself.         Then append the
                   //       command map to the given configuration as a macro handler
                   //
                   init(config) {
                        const map = new CommandMap(IFSTARMAP, {
                            DeclareIfstar: ['Declare_Ifstar']
                        }, {
                            //
                            //       Implements \DeclareIfstar control sequence.
                            //
                            Declare_Ifstar(parser, name) {
                                 //
                                 //    Get the control sequence to define and the starred and
                                 //    non-starred macros to use.
                                 //
                                 let cs = ParseUtil.trimSpaces(parser.GetArgument(name));
                                 const resultstar = parser.GetArgument(name);
                                 const resultnostar = parser.GetArgument(name);
                                 //
                                 //    Check that the control sequence name is valid
                                 //
                                 if (cs.charAt(0) === '\\') cs = cs.substr(1);
                                 if (!cs.match(/^(.|[a-z]+)$/i)) {         //$ syntax highlighting
                                      throw new TexError(
                                           'IllegalControlSequenceName',
                                           'Illegal control sequence name for %1',
                                           name
                                      );
                                 }
                                 //
                                 //    Look up the command map and add the new macro to it using
                                 //    IfstarFunction as the function and passing it the
                                 //    given starred and non-starred macros.
                                 //
                                 const map = parser.configuration.handlers.retrieve(IFSTARMAP);
                                 map.add(cs, new Macro(cs, IfstarFunction, [resultstar, resultnostar]));
                            }
                        });
                        config.append(
                            Configuration.create('IfstarDefs', {handler: {macro: [IFSTARMAP]}})
                        );
                   },


                   //
                   //       Add any user-defined starred/non-starred macros (from the
                   //       Ifstar configuration object in the document's
                   //       option list), if any.
                   //
                   config(config, jax) {
                        const map = jax.parseOptions.handlers.retrieve(IFSTARMAP);
                        const starmacros = jax.parseOptions.options.Ifstar;
                        for (const cs of Object.keys(starmacros)) {
                            map.add(cs, new Macro(cs, IfstarFunction, starmacros[cs]));
                        }
                   },


                   //
                   //       Indicate that Ifstar is a valid option, and can have
                   //       any number of definitions.         The format is
                   //
                   //                 name: [starred, non-starred]
                   //
                   //       where 'name' is the macro name, and starred and non-starred are the
                   //       macros to use for the \name macro.          You can include
                   //       pre-defined macros here, which will be available without
                   //       further configuration.
                   //
                   options: {
                        Ifstar: expandable({})
                   }
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });
         }        // ready
     },            // startup


     tex: {
         packages: {'[+]': ['seteqnumberCore', 'tagFormat', 'Ifstar']},
         seteqnumberCore: {
              seteqnumber: []                 // a user-defined macro
         },
         tags: "ams",
                   tagFormat: {
                            number: function (n) {
                                      if(MathJax.config.subequations==0)
                                           return(MathJax.config.section + n);
                                      else
                                           return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
         id="MathJax-script"
         src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
></script>

</head>
<body>


<a id="postGrad-autopage-33"></a>
<nav class="topnavigation" ><a href="index.html" class="linkhome" >
Home</a></nav>

<header>

<p>
<span
    class="fbox"
    style="display:inline-block ; border:1pt solid #000000; padding:3pt ; color:#000000"
>LOGO</span>
</p>

</header>


<div class="bodyandsidetoc" >
<div class="sidetoccontainer" >


<nav class="sidetoc" >


<div class="sidetoctitle" >

<p>
<span class="sidetocthetitle" >The Lwarp Tutorial</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents" >

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="index.html#autosec-8" class="tocchapter" >
<span class="sectionnumber" >1</span>&#x2003;Example chapter</a>
</p>


<p>
<a href="index.html#autosec-9" class="tocsection" >
<span class="sectionnumber" >1.1</span>&#x2003;A section</a>
</p>


<p>
<a href="index.html#autosec-16" class="tocsection" >
<span class="sectionnumber" >1.2</span>&#x2003;Some math</a>
</p>


<p>
<a href="index.html#autosec-18" class="tocchapter" >
<span class="sectionnumber" >2</span>&#x2003;Real Content</a>
</p>


<p>
<a href="index.html#autosec-21" class="tocsection" >
<span class="sectionnumber" >2.1</span>&#x2003;SQL</a>
</p>


</div>

</nav>

</div>


<div class="bodycontainer" >


<section class="textbody" >

<h1>The Lwarp Tutorial</h1>

<!--MathJax customizations:-->


<div class="hidden" >

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

</div>

<p>
<h3 id="autosec-34">Glossary</h3>
<a id="postGrad-autopage-34"></a>
<a id="postGrad-autofile-4"></a>
<p>
         <b>Adapter</b> The adapter pattern provides a wrapper with an interface required by the Application Programming Interface (API) client to link incompatible types and act as a translator between the two types. The adapter uses the interface of a class to
         be a class with another compatible interface. When requirements change, there are scenarios where class functionality needs to be changed because of incompatible interfaces. .
         </p>
<p>
         <b>API</b> An Application Programming Interface (API) is a particular set of rules and specifications that a software program can follow to access and make use of the services and resources provided by another particular software program that implements
         that API.
         </p>

<p>
           <b>Bridge</b> Bridge decouples the implementation from the abstraction. The abstract base class can be subclassed to provide different implementations and allow implementation details to be modified easily. .
           </p>

<p>
           <b>Debt To Equity</b> The debt-to-equity (D/E) ratio indicates how much debt a company is using to finance its assets relative to the value of shareholders’ equity. .
           </p>
<p>
           <b>Dependency Injection</b> Dependency injection means that, rather than being instantiated (”newed up”) within a class, each class’s dependencies will be injected in from the outside. .
           </p>
<p>
           <b>Dynamic libraries</b> libraries that are linked at run time .
           </p>

<p>
           <b>GAN</b> A GAN is a deep neural network architecture made up of two networks, a generator network and a discriminator network. Through multiple cycles of generation and discrimination, both networks train each other, while simultaneously trying to
           outwit each other..
           </p>
<p>
           <b>git</b> the most popular version control system used for tracking changes in source code and coordinating work on those files among multiple people .
           </p>

<p>
           <b>IoC</b> In software engineering, inversion of control (IoC) is a programming principle. IoC inverts the flow control as compared to traditional control flow. In IoC, custom-written portions of a computer program receive the flow of control from a generic
           framework. A software architecture with this design inverts control as compared to traditional procedural programming: in traditional programming, the custom code that expresses the purpose of the program calls into reusable libraries to take care of generic
           tasks, but with inversion of control, it is the framework that calls into the custom, or task-specific, code..
           </p>

<p>
           <b>Static libraries</b> libraries that are linked at compile time .
           </p>
<h4 id="autosec-35"></h4>
<a id="postGrad-autopage-35"></a>
<h3 id="autosec-36">Acronyms</h3>
<a id="postGrad-autopage-36"></a>

<p>
            <b>ABI</b> application binary interface.
            </p>

<p>
            <b>QPU</b> Quantum Processing Unit.
            </p>

<a id="postGrad-autofile-last"></a> </section>

</div>

</div>

<footer>

<p>
Contact Information and Copyright
</p>

</footer>


<nav class="botnavigation" ><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
